<?php
	/*
		Programmer:	Yogistra Anderson
		Date:		4/23/2010 6:58AM
		Desc:		Redesign, optimized DB_TABLE as base class singleton. (Does not support composite PKs)
		NOTE:		Sub-classes are auto generated by schema_to_tblClasses.php
					See DB_TABLE2_Template.php for example of sub-class.
		NOTE2:		All '2' affixed functions use prepared statement
					
		Interface:		
			- static object inst()											//returns singleton table instance			
			- bool 	new_record($ary_flds)									//create new record
			- int	new_record2($ary_flds)									//creates new record using prepared statement and binding variables
			- bool 	delete_record($pk)										//delete record
			- bool 	update_record($pk,$ary_flds,$ary_vals)						//update
			- bool 	update_record2($pk_val,$fld_val_map)
			- array	get_records($start_idx=0,$rec_count=100)						//get records
			- array	get_records_mp($start_idx=0,$rs_limit=100,&$recs_retrieved=NULL)		//get records as map, each record indexed by field name		
			- str 	get_records_as_xml($start_idx=0,$rs_limit=100,$root_tag='recordset',&$recs_retrieved=NULL)	//get records as XML string
			- str	filter_records_as_xml($fltr_ary,$start_idx=0,$rs_limit=100,&$recs_retrieved=NULL,orderby)	//get records as XML string, filtered
			- ary	filter_records2($fltr_ary,$start_idx=0,$rs_limit=100,&$recs_retrieved=NULL,$order_by=NULL)			
			- array	filter_records($filter_fld,$filter_val,$start_idx=0,$rec_count=100)	//filter records by field/column	
			- array	filter_records_mp($filter_fld,$filter_val,$start_idx=0,$rec_count=100)
			- array 	get_single_rec($pk_val)									//get single record by pk			
			- array		get_single_rec2($pk_val)	
			- map		get_single_rec_mp($pk_val){								//gets a single record as a map, with field names as the indexes
			- mixed 	get_single_col($pk_val,$fld_name);							//get a single column by pk
			- mixed  	get_column_val(&$rec,$col_nm);							//extract a column value from a record
			- array  protected abstract	get_field_names();						//must be implemented by subclass
			- string protected abstract function get_field_types();				//as above
			
			const DEF_PLC_HOLDER											//default place holder for new record
	*/
	
	require_once('DB_APP.php');
	
	//Exception classes: begin
	///////////////////////////////////////////////////////////////////////////////////////////////
	class Ex_DB_TABLE_Invalid_Param extends Exception{
		public function __construct($msg=''){parent::__construct('Ex_DB_TABLE_Invalid_Param,'.$msg);}
	}
	
	class Ex_DB_TABLE_Invalid_FldNm extends Exception{
		public function __construct($msg=''){parent::__construct('Ex_DB_TABLE_Invalid_FldNm,'.$msg);}
	}
	
	class Ex_DB_TABLE_Required_Param extends Exception{
		public function __construct($msg=''){parent::__construct('Ex_DB_TABLE_Required_Param,'.$msg);}
	}
	//Exception classes: end
	///////////////////////////////////////////////////////////////////////////////////////////////
	
	//class field: begin
	////////////////////////////////////////////////////////////////////////////	
	/*
		structure like class, represents a table's field
	*/
	class field{
		public $name 			 = null;
		public $type 			 = null;
		public $size			 = null;
		public $not_null 		 = null;
		public $is_pk 			 = null;
		public $has_default 	 = null;
		public $is_auto_increte = null;
		
		public function __construct($name,$type,$size=null,$not_null=false,$has_default=false,$is_auto_increte=false){
			$this->name 		= $name;
			$this->type 		= $type;
			$this->size			= $size;
			$this->not_null 	= $not_null;
			//$this->is_pk 		= $is_pk;
			$this->has_default 	= $has_default;
			$this->is_auto_increte = $is_auto_increte;
		}
	}
	//class field: end
	////////////////////////////////////////////////////////////////////////////
	
	//class DB_TABLE2: begin
	////////////////////////////////////////////////////////////////////////////
	abstract class DB_TABLE2{
		private static $_instance=NULL;		//singleton instance
		
		const DEF_PLC_HOLDER = -9999;		//placeholder constant, used for new_record method
		
		/**
			properties to be defined by sub-classes
		*/
		protected $fields;					//array of field objects
		protected $name;					//string name of table
		protected $PK_FIElD_IDX;			//int index of primary key field within $fields
		
		/**
		*	protected constructor, direct initialization not allowed go thru inst
		*/
		protected function __construct(){}
		
		/**
		*	MUST be implimented by sub-classes
		*/
		protected abstract function get_field_names();
		protected abstract function get_field_types();
		
		/**
			gets singleton instance
		*/	
		public static function inst(){
			if(!self::$_instance)
				self::$_instance = new DB_TABLE2();
				
			return self::$_instance;
		}
		
		public static function refValues($arr){			
			$refs = array();
			foreach($arr as $key => $value)
				$refs[$key] = &$arr[$key];
			return $refs;
		} 
		
		/**
			adds a new record using prepared statement and binding variables
		*/
		//public function new_record2($ary_flds){
		public function new_record2($ary_fld_vals){
			$fld_list = $this->get_field_names();
			$fldtps = $this->get_field_types();
			$val_plholders = '';
			
			//get a placeholder for each field
			for($i=1; $i<= count($fld_list); $i++){
				if($i != 1) $val_plholders .= ',';
				$val_plholders .= '?';
			}
				
			$sql = 'INSERT INTO '.$this->name.'('.implode(',',$fld_list).') VALUES('.$val_plholders.')';			
			$stmt = DB_APP::get_mysqli()->prepare($sql);
			
			// echo "SQL:$sql";
			// echo "field types:$fldtps";			 
						
			//array_unshift($ref_ary,$fldtps);	//add parameter types to beginning of array
			array_unshift($ary_fld_vals,$fldtps);	//add parameter types to beginning of array
			//print_r($ary_fld_vals);
			//call_user_func_array(Array($stmt,'bind_param'),self::refValues($ref_ary));
			$reflct = new ReflectionClass('mysqli_stmt');
			$method = $reflct->getMethod("bind_param");
			$method->invokeArgs($stmt,self::refValues($ary_fld_vals)); 
			
			//$stmt->bind_param(self::refValues($ary_fld_vals));
			$stmt->execute();
			$retval = $stmt->affected_rows;
			$stmt->close();
			
			if( $retval == -1 ){
				throw new Exception('[DB_TABLE2:new_record2] Failed to create record. ErrNo:'.DB_APP::get_mysqli()->errno.' Desc:'.DB_APP::get_mysqli()->error);
			}else{
				return true;
			}
		}
	
		/**
			adds a new record to the table
		*/
		public function new_record($ary_flds){
			$fld_list = $val_list = '';
			$fld_idx = 0;
			$is_first = true;			
					
			//loop thru all the table fields and pick out values from the input array
			foreach($this->fields as $field){
				
				//if field cannot be null, and its value is not supplied by auto_increment or default
				if($field->not_null && (!$field->is_auto_increte) && (!$field->has_default)){					
				
					//if required value not supplied, throw exception					
					if( !(isset($ary_flds[$fld_idx])) )
						throw new Ex_DB_TABLE_Required_Param('[DB_TABLE.new_record]: field '.$this->name.'.'.$field->name.' Required parameter not supplied!');
					
				}
				
				//echo("idx: $fld_idx, field: $field->name, val: ".(isset($ary_flds[$fld_idx])?$ary_flds[$fld_idx]:'null')."\n");				
				
				
				//if field is not not_incremented and a value is sent, read it
				if((!$field->is_auto_increte) && isset($ary_flds[$fld_idx]) && ($ary_flds[$fld_idx] != DB_TABLE2::DEF_PLC_HOLDER) ){
					//validate
					if(DB_APP::validate_field($ary_flds[$fld_idx],$field->type,$field->size)){
						$fld_list .= (($is_first)? '' : ',').$field->name;
						$val_list .= (($is_first)? '' : ',').DB_APP::prepare_data($ary_flds[$fld_idx],$field->type);
						$is_first=false;
					}
					else{
						//error_log('invalid field: '.$ary_flds[$fld_idx]);
						throw new Ex_DB_TABLE_Invalid_Param('[DB_TABLE.new_record]: field '.$field->name.' has an invalid parameter['.$ary_flds[$fld_idx].'!');
					}
				}
				
				$fld_idx++;
			}
			
			$sql = 'INSERT INTO '.$this->name.'('.$fld_list.') VALUES('.$val_list.')';
			//echo($sql);
			return DB_APP::exec($sql);
		}
		
		/**
			delete a record from the table
			@param $pk is primary key value
		*/
		public function delete_record($pk){			
			$pk_field_desc = $this->fields[$this->PK_FIELD_IDX];
											
			if(DB_APP::validate_field($pk,$pk_field_desc->type,$pk_field_desc->size)){
				$sql = 'DELETE FROM '.$this->name.' WHERE '.$pk_field_desc->name.'='.DB_APP::prepare_data($pk,$pk_field_desc->type);
				//echo($sql);
				return DB_APP::exec($sql);
			}
			else
				throw new Ex_DB_TABLE_Invalid_Param('[DB_TABLE.new_record]: Invalid parameter!');
		}
		
		/**
			updates record
			@param $pk is primary key value
			@param $ary_flds is array of field constants
			@param $ary_vals is array of field values
		*/
		public function update_record($pk,$ary_flds,$ary_vals){
			$loop_idx = 0;
			$pk_fld_desc = $this->fields[$this->PK_FIELD_IDX];			
			
			if(!DB_APP::validate_field($pk,$pk_fld_desc->type,$pk_fld_desc->size))
				throw new Ex_DB_TABLE_Invalid_Param('[DB_TABLE.update_record]: Invalid pk field!');						
			
			$sql = 'UPDATE '.$this->name.' SET ';
			
			//validate each field
			foreach($ary_flds as $fld_idx){
				$fld_desc = $this->fields[$fld_idx];
				
				if(!DB_APP::validate_field($ary_vals[$loop_idx],$fld_desc->type,$fld_desc->size))				
					throw new Ex_DB_TABLE_Invalid_Param('[DB_TABLE.update_record]: invalid parameter for field '.$fld_desc->name.'['.$ary_vals[$loop_idx].']!');
				
				$sql .= (($loop_idx > 0)? ',' : '').$fld_desc->name.'='.DB_APP::prepare_data($ary_vals[$loop_idx],$fld_desc->type);
				$loop_idx++;
			}
			
			$sql .= ' WHERE '.$pk_fld_desc->name.'='.DB_APP::prepare_data($pk,$pk_fld_desc->type);			
			//echo($sql);
			return DB_APP::exec($sql);
		}
		
		/**
			@param $pk is primary key value
			@param $fld_val_map is a array where the index represents the field index, and the value is the field value
		*/
		public function update_record2($pk_val,$fld_val_map){
			$fld_names = $this->get_field_names();
			$fld_tps = $this->get_field_types();
			$param_tps = '';
			
			$sql = 'UPDATE '.$this->name.' SET ';
			$is_first = true;
			
			foreach($fld_val_map as $fld_idx => $fld_val){
				if($is_first){
					$is_first = false;
				}else{
					$sql .= ',';	//add comma to seperate fields
				}
				
				$sql .= $fld_names[$fld_idx].'=?';
				$param_tps .= substr($fld_tps,$fld_idx,1);				//gather the type string used for binding
			}
			
			//append the WHERE clause to select the appropriate record
			$sql .= ' WHERE '.$fld_names[$this->PK_FIELD_IDX].'=?';
			$param_tps .= substr($fld_tps,$this->PK_FIELD_IDX,1);		//add the PK field to the type string
			
			$stmt = DB_APP::get_mysqli()->prepare($sql);				//prepared statement
			
			//reuse the input array as the binding array, add the pk value to the end of the array
			//add the field types string to the head
			array_push($fld_val_map,$pk_val);		
			array_unshift($fld_val_map,$param_tps);						//add parameter types to beginning of array
			//print_r($fltr_ary);
			
			//use reflection class to bind variable amount of parameters
			$reflct = new ReflectionClass('mysqli_stmt');				
			$method_bp = $reflct->getMethod("bind_param");					
			$method_bp->invokeArgs($stmt,self::refValues($fld_val_map)); //note we have to do the call to 
			
			/*
				$retval = $stmt->affected_rows;
			$stmt->close();
			
			if( $retval == -1 ){
				throw new Exception('[DB_TABLE2:new_record2] Failed to create record. ErrNo:'.DB_APP::get_mysqli()->errno.' Desc:'.DB_APP::get_mysqli()->error);
			}else{
				return true;
			}
			*/
			
			if( $stmt->execute() ){			
				$rows_affected = $stmt->affected_rows;
				$stmt->close();
				
				if( $rows_affected == 1 ){
					return true;
				}else{
					return false;
				}
			}else{
				$stmt->close();
				
				if(self::$mysqli->errno)
					throw new Exception('[DB_APP.update_records2]:('.DB_APP::get_mysqli()->errno.')'.DB_APP::get_mysqli()->error);
			}	
		}
		
		/**
			gets records from the database
		*/
		public function get_records($start_idx=0,$rs_limit=100,&$recs_retrieved=NULL){
			return DB_APP::get_records2('select * from '.$this->name,$start_idx,$rs_limit,$recs_retrieved);
		}		
		
		/**
			returns records as XML string
		*/
		public function get_records_as_xml($start_idx=0,$rs_limit=100,$root_tag='recordset',&$recs_retrieved=NULL,$order_by=NULL){
			$fld_names = $this->get_field_names();
			$sql = 'select * from '.$this->name;
			
			if( isset($order_by) ){
				$orderby_fld_idx = $order_by['fld_idx'];
				$orderby_is_asc = $order_by['is_asc'];
				
				$sql .= ' order by '.$fld_names[$orderby_fld_idx];
				$sql .= ($orderby_is_asc?' asc ':' desc');
			}
			
			$resultset = DB_APP::get_records2($sql,$start_idx,$rs_limit,$recs_retrieved);			
			$str_xml = "<{$root_tag}>";
			
			foreach($resultset as $record){
				$str_xml .= '<record>';
				$fld_idx = 0;
				
				foreach($record as $field){
					$str_xml .= '<'.$fld_names[$fld_idx].'>'.$field.'</'.$fld_names[$fld_idx].'>';
					$fld_idx++;
				}
				
				$str_xml .= '</record>';
			}
			
			$str_xml .= "</{$root_tag}>";
			
			return $str_xml;
		}
		
		/*
			filter records, returns res as XML(uses prepared statement)
			@param $fltr_ary : array(filterfield_idx => filterfield_val, ...);
			@param $order_by : array('fld_idx'=>INT,'is_asc'=>BOOL);
		*/
		public function filter_records_as_xml($fltr_ary,$start_idx=0,$rs_limit=100,&$recs_retrieved=NULL,$order_by=NULL){			
			$recordset_ary = $this->filter_records2($fltr_ary,$start_idx,$rs_limit,$recs_retrieved,$order_by);
			$fld_names = $this->get_field_names();
			$str_xml = '<recordset>';
			
			//error_log(print_r($recordset_ary));
			
			if( $recordset_ary != NULL ){
				foreach($recordset_ary as $rec){
					$str_xml .= '<record>';
					$fld_idx = 0;
					
					foreach($rec as $field){					
						$str_xml .= '<'.$fld_names[$fld_idx].'>'.$field.'</'.$fld_names[$fld_idx].'>';
						$fld_idx++;
					}
					
					$str_xml .= '</record>';
				}
			}			
				
			$str_xml .= '</recordset>';			
			return $str_xml;	
		}
		
		/*
			filter records, returns res as XML(uses prepared statement)
			@param $fltr_ary : array(filterfield_idx => filterfield_val, ...);
			@param $order_by : array('fld_idx'=>INT,'is_asc'=>BOOL);
		*/
		public function filter_records2($fltr_ary,$start_idx=0,$rs_limit=100,&$recs_retrieved=NULL,$order_by=NULL){
			$where_cls = '';
			$where_cls_tps = '';
			$fld_names = $this->get_field_names();
			$fld_tps = $this->get_field_types();
			$is_first = true;
			$str_xml = '';
			
			foreach($fltr_ary as $fldIdx => $fldVal){
				if(!$is_first){
					$where_cls .= ' and ';	
				}else{
					$is_first = false;
				}				
		
				$where_cls .= $fld_names[$fldIdx].'=?';
				$where_cls_tps .= substr($fld_tps,$fldIdx,1);
			}			
			
			//$sql = 'select * from '.$this->name.' where '.$where_cls.' LIMIT ? OFFSET ?';
			$sql = 'select '.implode($fld_names,',').' from '.$this->name.' where '.$where_cls;
			
			//if orderby array sent, use it to add order by params to the SQL 
			if( isset($order_by) ){
				$orderby_fld_idx = $order_by['fld_idx'];
				$orderby_is_asc = $order_by['is_asc'];
				
				$sql .= ' order by '.$fld_names[$orderby_fld_idx];
				$sql .= ($orderby_is_asc?' asc ':' desc');
			}
			
			$sql .= ' LIMIT ? OFFSET ?';
			
			//echo 'sql:'.$sql;
			
			$param_tps = $where_cls_tps.'ii';				//add the LIMIT and OFFSET param types to the string			
			$stmt = DB_APP::get_mysqli()->prepare($sql);	//prepare
			
			array_push($fltr_ary,$rs_limit);
			array_push($fltr_ary,$start_idx);
			array_unshift($fltr_ary,$param_tps);			//add parameter types to beginning of array
			//print_r($fltr_ary);
			
			//use reflection class to bind variable amount of parameters
			$reflct = new ReflectionClass('mysqli_stmt');				
			$method_bp = $reflct->getMethod("bind_param");					
			$method_bp->invokeArgs($stmt,self::refValues($fltr_ary)); 
			
			//echo 'count field names:'.count($fld_names).'//';
			
			if( $stmt->execute() ){				
				$stmt->store_result();	//buffer for better performance
				
				//make a ref Array from the fieldNames array(because it will match the result row exactly)				
				$byref_res_row = self::refValues($fld_names);		
				//$res_row = $fld_names;	
				$rec_count = 0;
				
				//echo('refArray results:');
				//print_r($res_row);
				
				//use reflection to invoke the method with a dynamic amount of parameters 
				$method_br = $reflct->getMethod("bind_result");
				$method_br->invokeArgs($stmt,$byref_res_row);
				$res_ary = array();
				
				while($stmt->fetch()){
					//new array
					$tmp_ary = array();
					//copy the values of the byref res array into the new array
					foreach($byref_res_row as $byref_res_key => $byref_res_val) $tmp_ary[$byref_res_key] = $byref_res_val;
					
					//add the array to the recordset
					$res_ary []= $tmp_ary;
					$fld_idx = 0;					
					
					$rec_count++;
				}			
				
				$stmt->close();
				
				if( isset($recs_retrieved) ) 
					$recs_retrieved = $rec_count++;
								
				return $res_ary;
			}else{
				//echo 'null result';
				if( isset($recs_retrieved) ) $recs_retrieved = 0;
				
				return null;
			}
		}
		
		
		
		/**
			get list of records, filtered by field
			@param $filter_fld is field constant identifying the filter field
			@param $filter_val is value to filter by
		*/
		public function filter_records_xml($filter_fld,$filter_val,$start_idx=0,$rec_count=100){
			$fld_desc = $this->fields[$filter_fld];
			
			if(!DB_APP::validate_field($filter_val,$fld_desc->type,$fld_desc->size)){				
				throw new Ex_DB_TABLE_Invalid_Param('[DB_TABLE.update_record]: invalid parameter for field '.$fld_desc->name.'!');
			}
			else{
				$sql = 'select * from '.$this->name.' where '.$fld_desc->name.'='.DB_APP::prepare_data($filter_val,$fld_desc->type);
				
				return DB_APP::get_records2($sql);
			}	
			
		}
		
		/**
			gets records from the database as map with field names as indexes
		*/
		public function get_records_mp($start_idx=0,$rs_limit=100,&$recs_retrieved=NULL){
			$resultset = $this->get_records2($start_idx,$rs_limit,$recs_retrieved);
			$fld_names = $this->get_field_names();
			$output_map = array();
			
			$record_idx = 0;
			foreach($resultset as $record){
				$output_map []= array();
				
				$fld_idx = 0;
				
				foreach($record as $field){
					$output_map[$record_idx][$fld_names[$fld_idx]] = $field;
					$fld_idx++;
				}
				
				$record_idx++;
			}
			
			return $output_map;
		}
		
		/**
			get list of records, filtered by field
			@param $filter_fld is field constant identifying the filter field
			@param $filter_val is value to filter by
		*/
		public function filter_records($filter_fld,$filter_val,$start_idx=0,$rec_count=100){
			$fld_desc = $this->fields[$filter_fld];
			
			if(!DB_APP::validate_field($filter_val,$fld_desc->type,$fld_desc->size)){				
				throw new Ex_DB_TABLE_Invalid_Param('[DB_TABLE.update_record]: invalid parameter for field '.$fld_desc->name.'!');
			}
			else{
				$sql = 'select * from '.$this->name.' where '.$fld_desc->name.'='.DB_APP::prepare_data($filter_val,$fld_desc->type);
				
				return DB_APP::get_records2($sql);
			}	
			
		}
		
		/*
			same as filter_records but returns an array of maps
		*/
		public function filter_records_mp($filter_fld,$filter_val,$start_idx=0,$rec_count=100){
			$fld_desc = $this->fields[$filter_fld];
			
			if(!DB_APP::validate_field($filter_val,$fld_desc->type,$fld_desc->size)){				
				throw new Ex_DB_TABLE_Invalid_Param('[DB_TABLE.update_record]: invalid parameter for field '.$fld_desc->name.'!');
			}
			else{
				$sql = 'select * from '.$this->name.' where '.$fld_desc->name.'='.DB_APP::prepare_data($filter_val,$fld_desc->type);				
				
				$resultset = DB_APP::get_records2($sql);
				$fld_names = $this->get_field_names();
				$output_map = array();
				
				$record_idx = 0;
				foreach($resultset as $record){
					$output_map []= array();
					
					$fld_idx = 0;
					
					foreach($record as $field){
						$output_map[$record_idx][$fld_names[$fld_idx]] = $field;
						$fld_idx++;
					}
					
					$record_idx++;
				}
				
				return $output_map;
			}
		}
		
		//gets a single record
		public function get_single_rec($pk_val){			
			$rs = $this->filter_records($this->PK_FIELD_IDX,$pk_val,0,1);
			return current($rs);
		}
		
		public function get_single_rec2($pk_val){			
			$rs = $this->filter_records2( array($this->PK_FIELD_IDX=>$pk_val),0,1 );
			
			if( ($rs == NULL) || (count($rs) == 0) ){
				return NULL;
			}else{				
				return current($rs);
			}
		}
		
		//gets a single record as a map, with field names as the indexes
		public function get_single_rec_mp($pk_val){			
			$resultset = $this->filter_records($this->PK_FIELD_IDX,$pk_val,0,1);			
			$record = current($resultset);
			$fld_names = $this->get_field_names();	//array of field names in the order as the database
			
			$map = array();
			$ary_idx = 0;			
			
			//load map, index by field names
			foreach($record as $field){
				$map[$fld_names[$ary_idx]] = $field;
				$ary_idx++;
			}
			
			return $map;
		}
		
		/**
			Retrieves a single column by primary key, different from @see get_column_val() which
			extracts a column from an already retrieved record.
			@param $col_idx is the field index constant
			@return mixed
		*/
		public function get_single_col($pk,$col_idx){
			$pk_fld_desc = $this->fields[$this->PK_FIELD_IDX];
						
			if( DB_APP::validate_field($pk,$pk_fld_desc->type,$pk_fld_desc->size) ){
				if( isset($this->fields[$col_idx]) ){
					$sql = 'select '.$this->fields[$col_idx]->name.' from '.$this->name.' where '.$pk_fld_desc->name.'='.DB_APP::prepare_data($pk,$pk_fld_desc->type);
					$res = DB_APP::get_records2($sql);
					
					if(!count($res))
						return NULL;
					else
						return $res[0][0];
				}else
					throw new Ex_DB_TABLE_Invalid_FldNm('[DB_TABLE::get_single_col]:Invalid field index['.$col_idx.']');
			}else{
				throw new Ex_DB_TABLE_Invalid_Param('[DB_TABLE::get_single_col]:Invalid pk field['.$pk.']');
			}
		}
		
		/**
			utility function, gets the value of a specific column, used if the position of the column is unknown
			@param $rec is the record to search
			@param $col_idx is the field constant index
		*/
		public function get_column_val(&$rec,$col_idx){	return $rec[$col_idx]; }		
	}
	//DB_TABLE2: End
	////////////////////////////////////////////////////////////////////////////
?>